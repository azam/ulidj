<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ULID.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ulidj</a> &gt; <a href="index.source.html" class="el_package">io.azam.ulidj</a> &gt; <span class="el_source">ULID.java</span></div><h1>ULID.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright (c) 2016-2025 Azamshul Azizy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package io.azam.ulidj;

import java.io.Serializable;
import java.security.SecureRandom;
import java.time.Clock;
import java.util.Arrays;
import java.util.Random;

/**
 * ULID implementation in Java. This class implements an immutable, sortable (implements
 * {@link java.lang.Comparable}) ULID instance, convertors and helper methods for ULID string,
 * binary representations.&lt;br&gt;
 * &lt;br&gt;
 * ULID string representations are generated as upper case letters. Parsing of ULID strings allow
 * upper and lower case letters, where `i` and `l` will be treated as `1` and `o` will be treated as
 * `0`. &lt;br&gt;
 * &lt;br&gt;
 *
 * ULID instance generation examples:&lt;br&gt;
 *
 * &lt;pre&gt;
 * // Using default Random instance backed by SecureRandom
 * ULID ulid1 = ULID.randomULID();
 * // Using provided Random instance
 * ULID ulid2 = ULID.randomULID(ThreadLocalRandom.current());
 * // Using provided SecureRandom instance
 * ULID ulid3 = ULID.parseULID(&quot;003JZ9J6G80123456789abcdef&quot;);
 * // Convert ULID string to ULID instance
 * ULID ulid4 = ULID.parseULID(&quot;003JZ9J6G80123456789abcdef&quot;);
 * // Convert ULID binary to ULID instance
 * ULID ulid5 = ULID.parseULID(
 *     new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf});
 * // Instantiate a ULID instance from current time and provided entropy bytes
 * ULID ulid6 = ULID.generateULID(System.currentTimeMillis(), entropy);
 * // Sort ULID instances lexicographically
 * List&amp;lt;ULID&amp;gt; ulids = Arrays.asList(ulid1, ulid2, ulid3, ulid4, ulid5, ulid6);
 * Collections.sort(ulids);
 * &lt;/pre&gt;
 *
 * ULID string generation examples:&lt;br&gt;
 *
 * &lt;pre&gt;
 * // Using default Random instance backed by SecureRandom
 * String ulid1 = ULID.random();
 * // Using provided Random instance
 * String ulid2 = ULID.random(ThreadLocalRandom.current());
 * // Using provided SecureRandom instance
 * String ulid3 = ULID.random(SecureRandom.newInstance(&quot;SHA1PRNG&quot;));
 * // Generate ULID string from current time and provided entropy bytes
 * byte[] entropy = new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9};
 * String ulid4 = ULID.generate(System.currentTimeMillis(), entropy);
 * // Convert ULID binary to ULID string
 * String ulid5 = ULID.fromBinary(
 *     new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf});
 * &lt;/pre&gt;
 *
 * ULID binary generation examples:&lt;br&gt;
 *
 * &lt;pre&gt;
 * // Using default Random instance backed by SecureRandom
 * byte[] ulid1 = ULID.randomBinary();
 * // Using provided Random instance
 * byte[] ulid2 = ULID.randomBinary(ThreadLocalRandom.current());
 * // Using provided SecureRandom instance
 * byte[] ulid3 = ULID.randomBinary(SecureRandom.newInstance(&quot;SHA1PRNG&quot;));
 * // Generate ULID string from current time and provided entropy bytes
 * byte[] entropy = new byte[] {0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9};
 * byte[] ulid4 = ULID.generateBinary(System.currentTimeMillis(), entropy);
 * // Convert ULID string to ULID binary
 * byte[] ulid5 = ULID.toBinary(&quot;003JZ9J6G80123456789abcdef&quot;);
 * &lt;/pre&gt;
 *
 * ULID utilities:&lt;br&gt;
 *
 * &lt;pre&gt;
 * String ulid = &quot;003JZ9J6G80123456789abcdef&quot;;
 * // Validate ULID string
 * assert ULID.isValid(ulid);
 * // Get timestamp from ULID string
 * long ts = ULID.getTimestamp(ulid);
 * assert ts == 123456789000L;
 * // Get entropy from ULID string
 * byte[] entropy = ULID.getEntropy(ulid);
 *
 * byte[] ulidBinary =
 *     new byte[] {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf};
 * // Validate ULID binary
 * assert ULID.isValidBinary(ulidBinary);
 * // Get timestamp from ULID binary
 * long tsBinary = ULID.getTimestampBinary(ulidBinary);
 * assert tsBinary == 1L;
 * // Get entropy from ULID binary
 * byte[] entropyBinary = ULID.getEntropyBinary(ulidBinary);
 * &lt;/pre&gt;
 *
 * ULID string representation:&lt;br&gt;
 *
 * &lt;pre&gt;
 *  01AN4Z07BY      79KA1307SR9X4MV3
 * |----------|    |----------------|
 *  Timestamp          Randomness
 *    48bits             80bits
 * &lt;/pre&gt;
 *
 * ULID binary representation:&lt;br&gt;
 *
 * &lt;pre&gt;
 * |0                   1                   2                   3  |
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                      32_bit_uint_time_high                    |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     16_bit_uint_time_low      |       16_bit_uint_random      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       32_bit_uint_random                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                       32_bit_uint_random                      |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * &lt;/pre&gt;
 *
 * @author azam
 * @since 0.0.1
 *
 * @see &lt;a href=&quot;https://github.com/azam&quot;&gt;ulidj&lt;/a&gt;
 * @see &lt;a href=&quot;https://github.com/ulid/spec&quot;&gt;ULID Specification&lt;/a&gt;
 * @see &lt;a href=&quot;https://www.crockford.com/wrmg/base32.html&quot;&gt;Crockford Base32 Encoding&lt;/a&gt;
 */
public final class ULID implements Serializable, Comparable&lt;ULID&gt; {
  private static final long serialVersionUID = 1L;

  /**
   * ULID string length.
   *
   * @since 0.0.1
   */
  public static final int ULID_LENGTH = 26;

  /**
   * ULID binary length.
   *
   * @since 1.0.4
   */
  public static final int ULID_BINARY_LENGTH = 16;

  /**
   * ULID entropy byte length.
   *
   * @since 1.0.3
   */
  public static final int ENTROPY_LENGTH = 10;

  /**
   * Minimum allowed timestamp value.
   *
   * @since 0.0.1
   */
  public static final long MIN_TIME = 0x0L;

  /**
   * Maximum allowed timestamp value. Encoded value can encode up to 0x0003ffffffffffffL but ULID
   * binary/byte representation states that timestamp will only be 48-bits.
   *
   * @since 0.0.1
   */
  public static final long MAX_TIME = 0x0000ffffffffffffL;

  /**
   * Base32 characters mapping
   *
   * @since 0.0.1
   */
<span class="fc" id="L192">  private static final char[] C = new char[] { //</span>
      0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, //
      0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, //
      0x47, 0x48, 0x4a, 0x4b, 0x4d, 0x4e, 0x50, 0x51, //
      0x52, 0x53, 0x54, 0x56, 0x57, 0x58, 0x59, 0x5a //
  };

  /**
   * {@code char} to {@code byte} O(1) mapping with alternative chars mapping
   */
<span class="fc" id="L202">  private static final byte[] V = new byte[] { //</span>
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03, //
      (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, //
      (byte) 0x08, (byte) 0x09, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0x0a, (byte) 0x0b, (byte) 0x0c, //
      (byte) 0x0d, (byte) 0x0e, (byte) 0x0f, (byte) 0x10, //
      (byte) 0x11, (byte) 0xff, (byte) 0x12, (byte) 0x13, //
      (byte) 0xff, (byte) 0x14, (byte) 0x15, (byte) 0xff, //
      (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, //
      (byte) 0x1a, (byte) 0xff, (byte) 0x1b, (byte) 0x1c, //
      (byte) 0x1d, (byte) 0x1e, (byte) 0x1f, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0x0a, (byte) 0x0b, (byte) 0x0c, //
      (byte) 0x0d, (byte) 0x0e, (byte) 0x0f, (byte) 0x10, //
      (byte) 0x11, (byte) 0xff, (byte) 0x12, (byte) 0x13, //
      (byte) 0xff, (byte) 0x14, (byte) 0x15, (byte) 0xff, //
      (byte) 0x16, (byte) 0x17, (byte) 0x18, (byte) 0x19, //
      (byte) 0x1a, (byte) 0xff, (byte) 0x1b, (byte) 0x1c, //
      (byte) 0x1d, (byte) 0x1e, (byte) 0x1f, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, //
      (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff //
  };

  /**
   * This allows lazy initialization of the default {@link java.util.Random} instance, backed by
   * {@link java.security.SecureRandom} instance.
   *
   * @since 1.1.0
   */
  private static class LazyDefaults {
    /**
     * Default {@link java.util.Random} instance.
     *
     * @since 1.1.0
     */
<span class="fc" id="L281">    static final Random random = new SecureRandom();</span>
  }

  private final byte[] binary;

  /**
   * Constructs an immutable ULID instance using provided ULID binary byte array.
   *
   * @param value ULID binary
   * @throws IllegalArgumentException if the ULID binary byte array is not valid
   * @since 1.1.0
   */
<span class="fc" id="L293">  private ULID(byte[] value) {</span>
<span class="fc" id="L294">    this.binary = Arrays.copyOf(value, ULID_BINARY_LENGTH);</span>
<span class="fc" id="L295">  }</span>

  /**
   * Extract and return the timestamp part of this ULID instance.
   *
   * @return Unix epoch timestamp in millisecond
   * @since 1.1.0
   */
  public long getTimestamp() {
<span class="fc" id="L304">    return getTimestampBinary(this.binary);</span>
  }

  /**
   * Extract and return the entropy part of this ULID instance.
   *
   * @return Entropy bytes
   * @since 1.1.0
   */
  public byte[] getEntropy() {
<span class="fc" id="L314">    return getEntropyBinary(this.binary);</span>
  }

  /**
   * Convert this ULID instance to its ULID binary representation.
   *
   * @return ULID binary
   * @since 1.1.0
   */
  public byte[] toBinary() {
<span class="fc" id="L324">    return Arrays.copyOf(this.binary, ULID_BINARY_LENGTH);</span>
  }

  /**
   * Convert this ULID instance to its ULID string representation.
   *
   * @return ULID string
   * @since 1.1.0
   */
  @Override
  public String toString() {
<span class="fc" id="L335">    return fromBinary(this.binary);</span>
  }

  /**
   * Compares ULID instance lexicographically.&lt;br&gt;
   * &lt;br&gt;
   * If the two ULID instances share a common prefix, then the lexicographic comparison is the
   * result of comparing the rest of the value of the two ULID instances.&lt;br&gt;
   * &lt;br&gt;
   * A null ULID instance reference is considered lexicographically less than a non-null ULID
   * instance reference.&lt;br&gt;
   * &lt;br&gt;
   * Two null ULID instances references are considered equal.&lt;br&gt;
   * &lt;br&gt;
   * The comparison is consistent with equals, where the ULID instances are equal if and only if
   * they are lexicographically equal.
   *
   * @param obj the ULID instance to compare
   * @return the value 0 if the ULID instance are equal and contain the same value; a value less
   *         than 0 if this ULID instance is lexicographically less than the ULID instance; and a
   *         value greater than 0 if this ULID instance is lexicographically greater than the ULID
   *         instance
   * @since 1.1.0
   */
  @Override
  public int compareTo(ULID obj) {
<span class="fc" id="L361">    return compare(this, obj);</span>
  }

  /**
   * Compares this object to the specified object. The result is true if and only if the argument is
   * not null, is a ULID instance and has the same timestamp and entropy.
   *
   * @param obj the ULID instance to compare with
   * @return true if the objects are the same; false otherwise
   * @since 1.1.0
   */
  @Override
  public boolean equals(Object obj) {
<span class="fc bfc" id="L374" title="All 4 branches covered.">    if ((null == obj) || (obj.getClass() != ULID.class))</span>
<span class="fc" id="L375">      return false;</span>
<span class="fc" id="L376">    return Arrays.equals(this.binary, ((ULID) obj).binary);</span>
  }

  /**
   * Returns a hash code for this ULID instance.
   *
   * @return A hash code value for this ULID instance
   * @since 1.1.0
   */
  @Override
  public int hashCode() {
<span class="fc" id="L387">    return 67 * Arrays.hashCode(this.binary);</span>
  }

  /**
   * Compares two ULID instances lexicographically.&lt;br&gt;
   * &lt;br&gt;
   * If the two ULID instances share a common prefix, then the lexicographic comparison is the
   * result of comparing the rest of the value of the two ULID instances.&lt;br&gt;
   * &lt;br&gt;
   * A null ULID instance reference is considered lexicographically less than a non-null ULID
   * instance reference.&lt;br&gt;
   * &lt;br&gt;
   * The comparison is consistent with equals, where the ULID instances are equal if and only if
   * they are lexicographically equal.
   *
   * @param a the first ULID instance to compare
   * @param b the second ULID instance to compare
   * @return the value 0 if the first and second ULID instance are equal and contain the same value;
   *         a value less than 0 if the first ULID instance is lexicographically less than the
   *         second ULID instance; and a value greater than 0 if the first ULID instance is
   *         lexicographically greater than the second ULID instance
   * @since 1.1.0
   */
  public static int compare(ULID a, ULID b) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">    if (a == b)</span>
<span class="fc" id="L412">      return 0;</span>
<span class="fc bfc" id="L413" title="All 4 branches covered.">    if (a == null || b == null)</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">      return a == null ? -1 : 1;</span>
    // {@link Arrays.compareUnsigned(byte[], byte[])} is not available in Java 7
<span class="fc" id="L416">    int len = Math.min(a.binary.length, b.binary.length);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L418">      int aInt = a.binary[i] &amp; 0xff;</span>
<span class="fc" id="L419">      int bInt = b.binary[i] &amp; 0xff;</span>
<span class="fc" id="L420">      int cmp = Integer.compare(aInt, bInt);</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">      if (cmp != 0)</span>
<span class="fc" id="L422">        return cmp;</span>
    }
<span class="fc" id="L424">    return a.binary.length - b.binary.length;</span>
  }

  /**
   * Generate random ULID string using default {@link java.util.Random} instance backed by
   * {@link java.security.SecureRandom} for entropy and {@link System#currentTimeMillis()} for
   * timestamp.
   *
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 0.0.1
   */
  public static String random() {
<span class="fc" id="L437">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L438">    LazyDefaults.random.nextBytes(entropy);</span>
<span class="fc" id="L439">    return generate(System.currentTimeMillis(), entropy);</span>
  }

  /**
   * Generate random ULID binary using default {@link java.util.Random} instance backed by
   * {@link java.security.SecureRandom} for entropy and {@link System#currentTimeMillis()} for
   * timestamp.
   *
   * @return ULID binary
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 1.0.4
   */
  public static byte[] randomBinary() {
<span class="fc" id="L452">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L453">    LazyDefaults.random.nextBytes(entropy);</span>
<span class="fc" id="L454">    return generateBinary(System.currentTimeMillis(), entropy);</span>
  }

  /**
   * Generate random ULID instance using default {@link java.util.Random} instance backed by
   * {@link java.security.SecureRandom} for entropy and {@link System#currentTimeMillis()} for
   * timestamp.
   *
   * @return ULID instance
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 1.1.0
   */
  public static ULID randomULID() {
<span class="fc" id="L467">    return new ULID(randomBinary());</span>
  }

  /**
   * Generate random ULID string using provided {@link java.util.Random} instance for entropy and
   * {@link System#currentTimeMillis()} for timestamp.
   *
   * @param random {@link java.util.Random} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 0.0.1
   */
  public static String random(Random random) {
<span class="fc" id="L480">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L481">    random.nextBytes(entropy);</span>
<span class="fc" id="L482">    return generate(System.currentTimeMillis(), entropy);</span>
  }

  /**
   * Generate random ULID binary using provided {@link java.util.Random} instance for entropy and
   * {@link System#currentTimeMillis()} for timestamp.
   *
   * @param random {@link java.util.Random} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 1.0.4
   */
  public static byte[] randomBinary(Random random) {
<span class="fc" id="L495">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L496">    random.nextBytes(entropy);</span>
<span class="fc" id="L497">    return generateBinary(System.currentTimeMillis(), entropy);</span>
  }

  /**
   * Generate random ULID instance using provided {@link java.util.Random} instance for entropy and
   * {@link System#currentTimeMillis()} for timestamp.
   *
   * @param random {@link java.util.Random} instance
   * @return ULID instance
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 1.1.0
   */
  public static ULID randomULID(Random random) {
<span class="fc" id="L510">    return new ULID(randomBinary(random));</span>
  }

  /**
   * Generate random ULID string using provided {@link java.time.Clock} instance for timestamp and
   * default {@link java.util.Random} instance backed by {@link java.security.SecureRandom} for
   * entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static String random(Clock clock) {
<span class="fc" id="L524">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L525">    LazyDefaults.random.nextBytes(entropy);</span>
<span class="fc" id="L526">    return generate(clock.millis(), entropy);</span>
  }

  /**
   * Generate random ULID binary using provided {@link java.time.Clock} instance for timestamp and
   * default {@link java.util.Random} instance backed by {@link java.security.SecureRandom} for
   * entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static byte[] randomBinary(Clock clock) {
<span class="fc" id="L540">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L541">    LazyDefaults.random.nextBytes(entropy);</span>
<span class="fc" id="L542">    return generateBinary(clock.millis(), entropy);</span>
  }

  /**
   * Generate random ULID instance using provided {@link java.time.Clock} instance for timestamp and
   * default {@link java.util.Random} instance backed by {@link java.security.SecureRandom} for
   * entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @return ULID instance
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static ULID randomULID(Clock clock) {
<span class="fc" id="L556">    return new ULID(randomBinary(clock));</span>
  }

  /**
   * Generate random ULID string using provided {@link java.time.Clock} instance for timestamp and
   * {@link java.util.Random} instance for entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @param random {@link java.util.Random} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static String random(Clock clock, Random random) {
<span class="fc" id="L570">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L571">    random.nextBytes(entropy);</span>
<span class="fc" id="L572">    return generate(clock.millis(), entropy);</span>
  }

  /**
   * Generate random ULID binary using provided {@link java.time.Clock} instance for timestamp and
   * {@link java.util.Random} instance for entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @param random {@link java.util.Random} instance
   * @return ULID string
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static byte[] randomBinary(Clock clock, Random random) {
<span class="fc" id="L586">    byte[] entropy = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L587">    random.nextBytes(entropy);</span>
<span class="fc" id="L588">    return generateBinary(clock.millis(), entropy);</span>
  }

  /**
   * Generate random ULID instance using provided {@link java.time.Clock} instance for timestamp and
   * {@link java.util.Random} instance for entropy.
   *
   * @param clock {@link java.time.Clock} instance
   * @param random {@link java.util.Random} instance
   * @return ULID instance
   * @throws IllegalArgumentException if current time is out of ULID specification
   * @since 2.0.0
   */
  public static ULID randomULID(Clock clock, Random random) {
<span class="fc" id="L602">    return new ULID(randomBinary(clock, random));</span>
  }

  /**
   * Generate ULID string from Unix epoch timestamp in millisecond and entropy bytes. Throws
   * {@link java.lang.IllegalArgumentException} if timestamp is less than {@value #MIN_TIME}, is
   * more than {@value #MAX_TIME}, or entropy bytes is not 10 bytes.
   *
   * @param time Unix epoch timestamp in millisecond
   * @param entropy Entropy bytes
   * @return ULID string
   * @throws IllegalArgumentException if time is out of ULID specification, or entropy is less than
   *         10
   * @since 0.0.1
   */
  public static String generate(long time, byte[] entropy) {
<span class="fc bfc" id="L618" title="All 8 branches covered.">    if (time &lt; MIN_TIME || time &gt; MAX_TIME || entropy == null || entropy.length != ENTROPY_LENGTH)</span>
<span class="fc" id="L619">      throw new IllegalArgumentException(</span>
          &quot;Time is out of ULID specification, or entropy is less than 10 bytes or null&quot;);

<span class="fc" id="L622">    char[] chars = new char[ULID_LENGTH];</span>

    // time
<span class="fc" id="L625">    chars[0] = C[((byte) (time &gt;&gt;&gt; 45)) &amp; 0x1f];</span>
<span class="fc" id="L626">    chars[1] = C[((byte) (time &gt;&gt;&gt; 40)) &amp; 0x1f];</span>
<span class="fc" id="L627">    chars[2] = C[((byte) (time &gt;&gt;&gt; 35)) &amp; 0x1f];</span>
<span class="fc" id="L628">    chars[3] = C[((byte) (time &gt;&gt;&gt; 30)) &amp; 0x1f];</span>
<span class="fc" id="L629">    chars[4] = C[((byte) (time &gt;&gt;&gt; 25)) &amp; 0x1f];</span>
<span class="fc" id="L630">    chars[5] = C[((byte) (time &gt;&gt;&gt; 20)) &amp; 0x1f];</span>
<span class="fc" id="L631">    chars[6] = C[((byte) (time &gt;&gt;&gt; 15)) &amp; 0x1f];</span>
<span class="fc" id="L632">    chars[7] = C[((byte) (time &gt;&gt;&gt; 10)) &amp; 0x1f];</span>
<span class="fc" id="L633">    chars[8] = C[((byte) (time &gt;&gt;&gt; 5)) &amp; 0x1f];</span>
<span class="fc" id="L634">    chars[9] = C[((byte) (time)) &amp; 0x1f];</span>

    // entropy
<span class="fc" id="L637">    chars[10] = C[(byte) ((entropy[0] &amp; 0xff) &gt;&gt;&gt; 3)];</span>
<span class="fc" id="L638">    chars[11] = C[(byte) (((entropy[0] &lt;&lt; 2) | ((entropy[1] &amp; 0xff) &gt;&gt;&gt; 6)) &amp; 0x1f)];</span>
<span class="fc" id="L639">    chars[12] = C[(byte) (((entropy[1] &amp; 0xff) &gt;&gt;&gt; 1) &amp; 0x1f)];</span>
<span class="fc" id="L640">    chars[13] = C[(byte) (((entropy[1] &lt;&lt; 4) | ((entropy[2] &amp; 0xff) &gt;&gt;&gt; 4)) &amp; 0x1f)];</span>
<span class="fc" id="L641">    chars[14] = C[(byte) (((entropy[2] &lt;&lt; 1) | ((entropy[3] &amp; 0xff) &gt;&gt;&gt; 7)) &amp; 0x1f)];</span>
<span class="fc" id="L642">    chars[15] = C[(byte) (((entropy[3] &amp; 0xff) &gt;&gt;&gt; 2) &amp; 0x1f)];</span>
<span class="fc" id="L643">    chars[16] = C[(byte) (((entropy[3] &lt;&lt; 3) | ((entropy[4] &amp; 0xff) &gt;&gt;&gt; 5)) &amp; 0x1f)];</span>
<span class="fc" id="L644">    chars[17] = C[(byte) (entropy[4] &amp; 0x1f)];</span>
<span class="fc" id="L645">    chars[18] = C[(byte) ((entropy[5] &amp; 0xff) &gt;&gt;&gt; 3)];</span>
<span class="fc" id="L646">    chars[19] = C[(byte) (((entropy[5] &lt;&lt; 2) | ((entropy[6] &amp; 0xff) &gt;&gt;&gt; 6)) &amp; 0x1f)];</span>
<span class="fc" id="L647">    chars[20] = C[(byte) (((entropy[6] &amp; 0xff) &gt;&gt;&gt; 1) &amp; 0x1f)];</span>
<span class="fc" id="L648">    chars[21] = C[(byte) (((entropy[6] &lt;&lt; 4) | ((entropy[7] &amp; 0xff) &gt;&gt;&gt; 4)) &amp; 0x1f)];</span>
<span class="fc" id="L649">    chars[22] = C[(byte) (((entropy[7] &lt;&lt; 1) | ((entropy[8] &amp; 0xff) &gt;&gt;&gt; 7)) &amp; 0x1f)];</span>
<span class="fc" id="L650">    chars[23] = C[(byte) (((entropy[8] &amp; 0xff) &gt;&gt;&gt; 2) &amp; 0x1f)];</span>
<span class="fc" id="L651">    chars[24] = C[(byte) (((entropy[8] &lt;&lt; 3) | ((entropy[9] &amp; 0xff) &gt;&gt;&gt; 5)) &amp; 0x1f)];</span>
<span class="fc" id="L652">    chars[25] = C[(byte) (entropy[9] &amp; 0x1f)];</span>

<span class="fc" id="L654">    return new String(chars);</span>
  }

  /**
   * Generate ULID binary from Unix epoch timestamp in millisecond and entropy bytes. Throws
   * {@link java.lang.IllegalArgumentException} if timestamp is less than {@value #MIN_TIME}, is
   * more than {@value #MAX_TIME}, or entropy bytes not 10 bytes.
   *
   * @param time Unix epoch timestamp in millisecond
   * @param entropy Entropy bytes
   * @return ULID string
   * @throws IllegalArgumentException if time is out of ULID specification, or entropy is less than
   *         10
   * @since 1.0.4
   */
  public static byte[] generateBinary(long time, byte[] entropy) {
<span class="fc bfc" id="L670" title="All 8 branches covered.">    if (time &lt; MIN_TIME || time &gt; MAX_TIME || entropy == null || entropy.length != ENTROPY_LENGTH)</span>
<span class="fc" id="L671">      throw new IllegalArgumentException(</span>
          &quot;Time is out of ULID specification, or entropy is less than 10 bytes or null&quot;);

<span class="fc" id="L674">    byte[] bytes = new byte[ULID_BINARY_LENGTH];</span>

    // Long to big endian byte array up to 6 bytes
<span class="fc" id="L677">    long ts = time;</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">    for (int i = 5; i &gt;= 0; i--) {</span>
<span class="fc" id="L679">      bytes[i] = (byte) (ts &amp; 0xff);</span>
<span class="fc" id="L680">      ts = ts &gt;&gt;&gt; 8;</span>
    }

    // Copy over bytes from entropy
<span class="fc" id="L684">    System.arraycopy(entropy, 0, bytes, 6, 10);</span>

<span class="fc" id="L686">    return bytes;</span>
  }

  /**
   * Generate ULID instance from Unix epoch timestamp in millisecond and entropy bytes. Throws
   * {@link java.lang.IllegalArgumentException} if timestamp is less than {@value #MIN_TIME}, is
   * more than {@value #MAX_TIME}, or entropy bytes is null or less than 10 bytes.
   *
   * @param time Unix epoch timestamp in millisecond
   * @param entropy Entropy bytes
   * @return ULID instance
   * @throws IllegalArgumentException if time is out of ULID specification, or entropy is less than
   *         10
   * @since 1.1.0
   */
  public static ULID generateULID(long time, byte[] entropy) {
<span class="fc" id="L702">    return new ULID(generateBinary(time, entropy));</span>

  }

  /**
   * Checks ULID string validity.
   *
   * @param ulid ULID string
   * @return true if ULID string is valid
   * @since 0.0.1
   */
  public static boolean isValid(CharSequence ulid) {
<span class="fc bfc" id="L714" title="All 4 branches covered.">    if (ulid == null || ulid.length() != ULID_LENGTH)</span>
<span class="fc" id="L715">      return false;</span>
    // Maximum encodable timestamp is 50-bit, but ULID limits to 48-bit.
    // {@link ULID.MAX_TIME}
<span class="fc" id="L718">    char char0 = ulid.charAt(0);</span>
<span class="fc bfc" id="L719" title="All 6 branches covered.">    if (char0 &gt; V.length || V[char0] == (byte) 0xff || V[char0] &gt; 0x07)</span>
<span class="fc" id="L720">      return false;</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">    for (int i = 1; i &lt; ULID_LENGTH; i++) {</span>
      // We only care for chars between 0x00 and 0xff.
<span class="fc" id="L723">      char c = ulid.charAt(i);</span>
<span class="fc bfc" id="L724" title="All 4 branches covered.">      if (c &gt; V.length || V[c] == (byte) 0xff) {</span>
<span class="fc" id="L725">        return false;</span>
      }
    }
<span class="fc" id="L728">    return true;</span>
  }

  /**
   * Checks ULID binary validity.
   *
   * @param ulid ULID binary
   * @return true if ULID binary is valid
   * @since 1.0.4
   */
  public static boolean isValidBinary(byte[] ulid) {
<span class="fc bfc" id="L739" title="All 4 branches covered.">    return ulid != null &amp;&amp; ulid.length == ULID_BINARY_LENGTH;</span>
  }

  /**
   * Extract and return the timestamp part from ULID string. Expects a valid ULID string.
   *
   * @param ulid ULID string
   * @return Unix epoch timestamp in millisecond
   * @throws IllegalArgumentException if the ULID string is not valid
   * @since 0.0.1
   */
  public static long getTimestamp(CharSequence ulid) {
<span class="fc bfc" id="L751" title="All 2 branches covered.">    if (!isValid(ulid))</span>
<span class="fc" id="L752">      throw new IllegalArgumentException(&quot;Invalid ULID string&quot;);</span>
<span class="fc" id="L753">    return (long) V[ulid.charAt(0)] &lt;&lt; 45 //</span>
<span class="fc" id="L754">        | (long) V[ulid.charAt(1)] &lt;&lt; 40 //</span>
<span class="fc" id="L755">        | (long) V[ulid.charAt(2)] &lt;&lt; 35 //</span>
<span class="fc" id="L756">        | (long) V[ulid.charAt(3)] &lt;&lt; 30 //</span>
<span class="fc" id="L757">        | (long) V[ulid.charAt(4)] &lt;&lt; 25 //</span>
<span class="fc" id="L758">        | (long) V[ulid.charAt(5)] &lt;&lt; 20 //</span>
<span class="fc" id="L759">        | (long) V[ulid.charAt(6)] &lt;&lt; 15 //</span>
<span class="fc" id="L760">        | (long) V[ulid.charAt(7)] &lt;&lt; 10 //</span>
<span class="fc" id="L761">        | (long) V[ulid.charAt(8)] &lt;&lt; 5 //</span>
<span class="fc" id="L762">        | (long) V[ulid.charAt(9)];</span>
  }

  /**
   * Extract and return the timestamp part from ULID binary.
   *
   * @param ulid ULID string
   * @return Unix epoch timestamp in millisecond
   * @throws IllegalArgumentException if the ULID binary is not valid
   * @since 1.0.4
   */
  public static long getTimestampBinary(byte[] ulid) {
<span class="fc bfc" id="L774" title="All 2 branches covered.">    if (!isValidBinary(ulid))</span>
<span class="fc" id="L775">      throw new IllegalArgumentException(&quot;Invalid ULID binary&quot;);</span>
<span class="fc" id="L776">    long timestamp = (long) ulid[0] &amp; 0xff;</span>
<span class="fc" id="L777">    timestamp = (timestamp &lt;&lt; 8) | ulid[1] &amp; 0xff;</span>
<span class="fc" id="L778">    timestamp = (timestamp &lt;&lt; 8) | ulid[2] &amp; 0xff;</span>
<span class="fc" id="L779">    timestamp = (timestamp &lt;&lt; 8) | ulid[3] &amp; 0xff;</span>
<span class="fc" id="L780">    timestamp = (timestamp &lt;&lt; 8) | ulid[4] &amp; 0xff;</span>
<span class="fc" id="L781">    timestamp = (timestamp &lt;&lt; 8) | ulid[5] &amp; 0xff;</span>
<span class="fc" id="L782">    return timestamp;</span>
  }

  /**
   * Extract and return the entropy part from ULID string.
   *
   * @param ulid ULID string
   * @return Entropy bytes
   * @throws IllegalArgumentException if the ULID string is not valid
   * @since 0.0.1
   */
  public static byte[] getEntropy(CharSequence ulid) {
<span class="fc bfc" id="L794" title="All 2 branches covered.">    if (!isValid(ulid))</span>
<span class="fc" id="L795">      throw new IllegalArgumentException(&quot;Invalid ULID string&quot;);</span>
<span class="fc" id="L796">    byte[] bytes = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L797">    bytes[0] = (byte) ((V[ulid.charAt(10)] &lt;&lt; 3) //</span>
<span class="fc" id="L798">        | (V[ulid.charAt(11)] &amp; 0xff) &gt;&gt;&gt; 2);</span>
<span class="fc" id="L799">    bytes[1] = (byte) ((V[ulid.charAt(11)] &lt;&lt; 6) //</span>
<span class="fc" id="L800">        | V[ulid.charAt(12)] &lt;&lt; 1 //</span>
<span class="fc" id="L801">        | (V[ulid.charAt(13)] &amp; 0xff) &gt;&gt;&gt; 4);</span>
<span class="fc" id="L802">    bytes[2] = (byte) ((V[ulid.charAt(13)] &lt;&lt; 4) //</span>
<span class="fc" id="L803">        | (V[ulid.charAt(14)] &amp; 0xff) &gt;&gt;&gt; 1);</span>
<span class="fc" id="L804">    bytes[3] = (byte) ((V[ulid.charAt(14)] &lt;&lt; 7) //</span>
<span class="fc" id="L805">        | V[ulid.charAt(15)] &lt;&lt; 2 //</span>
<span class="fc" id="L806">        | (V[ulid.charAt(16)] &amp; 0xff) &gt;&gt;&gt; 3);</span>
<span class="fc" id="L807">    bytes[4] = (byte) ((V[ulid.charAt(16)] &lt;&lt; 5) //</span>
<span class="fc" id="L808">        | V[ulid.charAt(17)]);</span>
<span class="fc" id="L809">    bytes[5] = (byte) ((V[ulid.charAt(18)] &lt;&lt; 3) //</span>
<span class="fc" id="L810">        | (V[ulid.charAt(19)] &amp; 0xff) &gt;&gt;&gt; 2);</span>
<span class="fc" id="L811">    bytes[6] = (byte) ((V[ulid.charAt(19)] &lt;&lt; 6) //</span>
<span class="fc" id="L812">        | V[ulid.charAt(20)] &lt;&lt; 1 //</span>
<span class="fc" id="L813">        | (V[ulid.charAt(21)] &amp; 0xff) &gt;&gt;&gt; 4);</span>
<span class="fc" id="L814">    bytes[7] = (byte) ((V[ulid.charAt(21)] &lt;&lt; 4) //</span>
<span class="fc" id="L815">        | (V[ulid.charAt(22)] &amp; 0xff) &gt;&gt;&gt; 1);</span>
<span class="fc" id="L816">    bytes[8] = (byte) ((V[ulid.charAt(22)] &lt;&lt; 7) //</span>
<span class="fc" id="L817">        | V[ulid.charAt(23)] &lt;&lt; 2 //</span>
<span class="fc" id="L818">        | (V[ulid.charAt(24)] &amp; 0xff) &gt;&gt;&gt; 3);</span>
<span class="fc" id="L819">    bytes[9] = (byte) ((V[ulid.charAt(24)] &lt;&lt; 5) //</span>
<span class="fc" id="L820">        | V[ulid.charAt(25)]);</span>
<span class="fc" id="L821">    return bytes;</span>
  }

  /**
   * Extract and return the entropy part from ULID binary.
   *
   * @param ulid ULID binary
   * @return Entropy bytes
   * @throws IllegalArgumentException if the ULID binary is not valid
   * @since 1.0.4
   */
  public static byte[] getEntropyBinary(byte[] ulid) {
<span class="fc bfc" id="L833" title="All 2 branches covered.">    if (!isValidBinary(ulid))</span>
<span class="fc" id="L834">      throw new IllegalArgumentException(&quot;Invalid ULID binary&quot;);</span>
<span class="fc" id="L835">    byte[] bytes = new byte[ENTROPY_LENGTH];</span>
<span class="fc" id="L836">    System.arraycopy(ulid, 6, bytes, 0, 10);</span>
<span class="fc" id="L837">    return bytes;</span>
  }

  /**
   * Convert a valid ULID string representation to its binary representation.
   *
   * @param ulid ULID string
   * @return ULID binary
   * @throws IllegalArgumentException if the ULID string is not valid
   * @since 1.0.4
   */
  public static byte[] toBinary(CharSequence ulid) {
<span class="fc bfc" id="L849" title="All 2 branches covered.">    if (!isValid(ulid))</span>
<span class="fc" id="L850">      throw new IllegalArgumentException(&quot;Invalid ULID string&quot;);</span>
<span class="fc" id="L851">    byte[] bytes = new byte[ULID_BINARY_LENGTH];</span>
    // Timestamp
<span class="fc" id="L853">    bytes[0] = (byte) ((V[ulid.charAt(0)] &lt;&lt; 5) //</span>
<span class="fc" id="L854">        | V[ulid.charAt(1)]);</span>
<span class="fc" id="L855">    bytes[1] = (byte) ((V[ulid.charAt(2)] &lt;&lt; 3) //</span>
<span class="fc" id="L856">        | (V[ulid.charAt(3)] &amp; 0xff) &gt;&gt;&gt; 2);</span>
<span class="fc" id="L857">    bytes[2] = (byte) ((V[ulid.charAt(3)] &lt;&lt; 6) //</span>
<span class="fc" id="L858">        | V[ulid.charAt(4)] &lt;&lt; 1 //</span>
<span class="fc" id="L859">        | (V[ulid.charAt(5)] &amp; 0xff) &gt;&gt;&gt; 4);</span>
<span class="fc" id="L860">    bytes[3] = (byte) ((V[ulid.charAt(5)] &lt;&lt; 4) //</span>
<span class="fc" id="L861">        | (V[ulid.charAt(6)] &amp; 0xff) &gt;&gt;&gt; 1);</span>
<span class="fc" id="L862">    bytes[4] = (byte) ((V[ulid.charAt(6)] &lt;&lt; 7) //</span>
<span class="fc" id="L863">        | V[ulid.charAt(7)] &lt;&lt; 2 //</span>
<span class="fc" id="L864">        | (V[ulid.charAt(8)] &amp; 0xff) &gt;&gt;&gt; 3);</span>
<span class="fc" id="L865">    bytes[5] = (byte) ((V[ulid.charAt(8)] &lt;&lt; 5) //</span>
<span class="fc" id="L866">        | V[ulid.charAt(9)]);</span>
    // Entropy
<span class="fc" id="L868">    bytes[6] = (byte) ((V[ulid.charAt(10)] &lt;&lt; 3) //</span>
<span class="fc" id="L869">        | (V[ulid.charAt(11)] &amp; 0xff) &gt;&gt;&gt; 2);</span>
<span class="fc" id="L870">    bytes[7] = (byte) ((V[ulid.charAt(11)] &lt;&lt; 6) //</span>
<span class="fc" id="L871">        | V[ulid.charAt(12)] &lt;&lt; 1 //</span>
<span class="fc" id="L872">        | (V[ulid.charAt(13)] &amp; 0xff) &gt;&gt;&gt; 4);</span>
<span class="fc" id="L873">    bytes[8] = (byte) ((V[ulid.charAt(13)] &lt;&lt; 4) //</span>
<span class="fc" id="L874">        | (V[ulid.charAt(14)] &amp; 0xff) &gt;&gt;&gt; 1);</span>
<span class="fc" id="L875">    bytes[9] = (byte) ((V[ulid.charAt(14)] &lt;&lt; 7) //</span>
<span class="fc" id="L876">        | V[ulid.charAt(15)] &lt;&lt; 2 //</span>
<span class="fc" id="L877">        | (V[ulid.charAt(16)] &amp; 0xff) &gt;&gt;&gt; 3);</span>
<span class="fc" id="L878">    bytes[10] = (byte) ((V[ulid.charAt(16)] &lt;&lt; 5) //</span>
<span class="fc" id="L879">        | V[ulid.charAt(17)]);</span>
<span class="fc" id="L880">    bytes[11] = (byte) ((V[ulid.charAt(18)] &lt;&lt; 3) //</span>
<span class="fc" id="L881">        | (V[ulid.charAt(19)] &amp; 0xff) &gt;&gt;&gt; 2);</span>
<span class="fc" id="L882">    bytes[12] = (byte) ((V[ulid.charAt(19)] &lt;&lt; 6) //</span>
<span class="fc" id="L883">        | V[ulid.charAt(20)] &lt;&lt; 1 //</span>
<span class="fc" id="L884">        | (V[ulid.charAt(21)] &amp; 0xff) &gt;&gt;&gt; 4);</span>
<span class="fc" id="L885">    bytes[13] = (byte) ((V[ulid.charAt(21)] &lt;&lt; 4) //</span>
<span class="fc" id="L886">        | (V[ulid.charAt(22)] &amp; 0xff) &gt;&gt;&gt; 1);</span>
<span class="fc" id="L887">    bytes[14] = (byte) ((V[ulid.charAt(22)] &lt;&lt; 7) //</span>
<span class="fc" id="L888">        | V[ulid.charAt(23)] &lt;&lt; 2 //</span>
<span class="fc" id="L889">        | (V[ulid.charAt(24)] &amp; 0xff) &gt;&gt;&gt; 3);</span>
<span class="fc" id="L890">    bytes[15] = (byte) ((V[ulid.charAt(24)] &lt;&lt; 5) //</span>
<span class="fc" id="L891">        | V[ulid.charAt(25)]);</span>
<span class="fc" id="L892">    return bytes;</span>
  }

  /**
   * Convert a valid ULID binary representation to its string representation.
   *
   * @param ulid ULID binary
   * @return ULID string
   * @throws IllegalArgumentException if the ULID binary is not valid
   * @since 1.0.4
   */
  public static String fromBinary(byte[] ulid) {
<span class="fc bfc" id="L904" title="All 2 branches covered.">    if (!isValidBinary(ulid))</span>
<span class="fc" id="L905">      throw new IllegalArgumentException(&quot;Invalid ULID binary&quot;);</span>
<span class="fc" id="L906">    char[] chars = new char[ULID_LENGTH];</span>

    // time
<span class="fc" id="L909">    chars[0] = C[(byte) (((ulid[0] &amp; 0xff) &gt;&gt;&gt; 5) &amp; 0x1f)];</span>
<span class="fc" id="L910">    chars[1] = C[(byte) (ulid[0] &amp; 0x1f)];</span>
<span class="fc" id="L911">    chars[2] = C[(byte) ((ulid[1] &amp; 0xff) &gt;&gt;&gt; 3)];</span>
<span class="fc" id="L912">    chars[3] = C[(byte) (((ulid[1] &lt;&lt; 2) | ((ulid[2] &amp; 0xff) &gt;&gt;&gt; 6)) &amp; 0x1f)];</span>
<span class="fc" id="L913">    chars[4] = C[(byte) (((ulid[2] &amp; 0xff) &gt;&gt;&gt; 1) &amp; 0x1f)];</span>
<span class="fc" id="L914">    chars[5] = C[(byte) (((ulid[2] &lt;&lt; 4) | ((ulid[3] &amp; 0xff) &gt;&gt;&gt; 4)) &amp; 0x1f)];</span>
<span class="fc" id="L915">    chars[6] = C[(byte) (((ulid[3] &lt;&lt; 1) | ((ulid[4] &amp; 0xff) &gt;&gt;&gt; 7)) &amp; 0x1f)];</span>
<span class="fc" id="L916">    chars[7] = C[(byte) (((ulid[4] &amp; 0xff) &gt;&gt;&gt; 2) &amp; 0x1f)];</span>
<span class="fc" id="L917">    chars[8] = C[(byte) (((ulid[4] &lt;&lt; 3) | ((ulid[5] &amp; 0xff) &gt;&gt;&gt; 5)) &amp; 0x1f)];</span>
<span class="fc" id="L918">    chars[9] = C[(byte) (ulid[5] &amp; 0x1f)];</span>

    // entropy
<span class="fc" id="L921">    chars[10] = C[(byte) ((ulid[6] &amp; 0xff) &gt;&gt;&gt; 3)];</span>
<span class="fc" id="L922">    chars[11] = C[(byte) (((ulid[6] &lt;&lt; 2) | ((ulid[7] &amp; 0xff) &gt;&gt;&gt; 6)) &amp; 0x1f)];</span>
<span class="fc" id="L923">    chars[12] = C[(byte) (((ulid[7] &amp; 0xff) &gt;&gt;&gt; 1) &amp; 0x1f)];</span>
<span class="fc" id="L924">    chars[13] = C[(byte) (((ulid[7] &lt;&lt; 4) | ((ulid[8] &amp; 0xff) &gt;&gt;&gt; 4)) &amp; 0x1f)];</span>
<span class="fc" id="L925">    chars[14] = C[(byte) (((ulid[8] &lt;&lt; 1) | ((ulid[9] &amp; 0xff) &gt;&gt;&gt; 7)) &amp; 0x1f)];</span>
<span class="fc" id="L926">    chars[15] = C[(byte) (((ulid[9] &amp; 0xff) &gt;&gt;&gt; 2) &amp; 0x1f)];</span>
<span class="fc" id="L927">    chars[16] = C[(byte) (((ulid[9] &lt;&lt; 3) | ((ulid[10] &amp; 0xff) &gt;&gt;&gt; 5)) &amp; 0x1f)];</span>
<span class="fc" id="L928">    chars[17] = C[(byte) (ulid[10] &amp; 0x1f)];</span>
<span class="fc" id="L929">    chars[18] = C[(byte) ((ulid[11] &amp; 0xff) &gt;&gt;&gt; 3)];</span>
<span class="fc" id="L930">    chars[19] = C[(byte) (((ulid[11] &lt;&lt; 2) | ((ulid[12] &amp; 0xff) &gt;&gt;&gt; 6)) &amp; 0x1f)];</span>
<span class="fc" id="L931">    chars[20] = C[(byte) (((ulid[12] &amp; 0xff) &gt;&gt;&gt; 1) &amp; 0x1f)];</span>
<span class="fc" id="L932">    chars[21] = C[(byte) (((ulid[12] &lt;&lt; 4) | ((ulid[13] &amp; 0xff) &gt;&gt;&gt; 4)) &amp; 0x1f)];</span>
<span class="fc" id="L933">    chars[22] = C[(byte) (((ulid[13] &lt;&lt; 1) | ((ulid[14] &amp; 0xff) &gt;&gt;&gt; 7)) &amp; 0x1f)];</span>
<span class="fc" id="L934">    chars[23] = C[(byte) (((ulid[14] &amp; 0xff) &gt;&gt;&gt; 2) &amp; 0x1f)];</span>
<span class="fc" id="L935">    chars[24] = C[(byte) (((ulid[14] &lt;&lt; 3) | ((ulid[15] &amp; 0xff) &gt;&gt;&gt; 5)) &amp; 0x1f)];</span>
<span class="fc" id="L936">    chars[25] = C[(byte) (ulid[15] &amp; 0x1f)];</span>

<span class="fc" id="L938">    return new String(chars);</span>
  }

  /**
   * Constructs an immutable ULID instance using provided ULID string.
   *
   * @param ulid ULID string
   * @return ULID instance
   * @throws IllegalArgumentException if the ULID string is not valid
   * @since 1.1.0
   */
  public static ULID parseULID(CharSequence ulid) {
<span class="fc" id="L950">    return new ULID(toBinary(ulid));</span>
  }

  /**
   * Constructs an immutable ULID instance using provided ULID binary byte array.
   *
   * @param ulid ULID binary
   * @return ULID instance
   * @throws IllegalArgumentException if the ULID binary byte array is not valid
   * @since 1.1.0
   */
  public static ULID parseULID(byte[] ulid) {
<span class="fc bfc" id="L962" title="All 2 branches covered.">    if (isValidBinary(ulid))</span>
<span class="fc" id="L963">      return new ULID(ulid);</span>
<span class="fc" id="L964">    throw new IllegalArgumentException(&quot;Invalid ULID binary&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>